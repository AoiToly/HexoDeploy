# UNITY – RPG游戏从框架到实战

## 软件设计原则：

1、适应变化

2、提高代码复用率

3、可维护性

4、可扩展性

## 设计原则：

单一职责：单个功能使用一个类去控制

开闭原则：不能直接访问类成员，应该使用Get、Set方法或其他方法封装

依赖倒置：1、先了解需求。2、先画图。3、变成代码。

接口隔离原则：接口里面的单一原则

里氏原则：不要修改别人的代码，重写父类的代码

多态：父类的指针指向子类而调用子类的方法

合成复用原则：1、将类抽象化，父类解决共有问题，子类解决特有问题

​    2、单纯抽象化使子类继承父类会导致类越写越多越来越复杂，可以让类中包含其他类的实例

即，多用组合少用继承

迪米特法则（又称最少知识原则）：假如A类中包含B类的实例，且A类中调用B类的方法，如果B类的方法改变，例如改变方法的参数，那么A类中的调用也需要进行调整，所以方法的调整尽量不要牵扯到其他类中的代码调整

## 设计模式：

### 单例模式

适用于整个软件生命周期有且只有一次实例，例如组织框架，每个模块的管理者

方法：public static

单例两种方式：

1、继承MonoBehavior  

用在组织框架的管理器上面

Public static test Instance;

Void Awake()

{
   Instance = this;

}

2、不继承MonoBehavior

Private static test instance;

Public static text Instance

{

  get

  {

If(Instance == null)

{
   Instance = new test();

}

Return this;

  }

}

### 工厂模式

作用：用于new一些新的对象

例如：生产野怪

特点：不关心生产过程

### 观察者模式

作用：不断地询问

方法：

​	1、计时操作，Time.deltaTime

​    2、事件监听模式

注意UnityAction是无返回值单参数委托类，利用new Unity Action注册事件的特点是，注册的事件保存在堆上

详情可看连的代码

### 策略者模式

根据不同的输入，得到不同的输出结果

实现方法：利用多态实现

### 建造者模式

金字塔结构，从主要的管理者开始，细分各个功能

### 中介者模式

类与类之间不互相关联，通过第三方解决，即第三个类

### 门面模式

将各种不同类型的东西放在一起形成特定的功能

类似于中介者模式，即将两种不同的组件通过控件控制，类似于父物体控制子物体

注意：在写脚本的过程中尽量不要public GameObject，因为这么写会增加耦合度，可以通过transform.find方法来找

另：transform.find方法用的是深度优先遍历dps

举例：坦克的各个部件，比如炮台、履带、车身



## ＷＷＷ封装

Get请求：

​	１、参数在链接里面，？问号后面是参数

​	

Post请求：

​	１、参数在表单里面

​	２、服务器
